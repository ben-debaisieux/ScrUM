#To edit and compare internal_properties, use WINDEV integrated tools.
#Internal properties refer to the properties of controls in windows, reports, etc.
info :
 name : CLZF_GenDataMSSQL
 major_version : 27
 minor_version : 0
 type : 4
 description : ""
 subtype : 0
class :
 identifier : 0x147657be00978709
 internal_properties : BwAAAAcAAAB2/vstTMCJbS/hlxjFxirSqKvCUuv8YxgpWyl7S3iA
 code_elements :
  type_code : 10
  p_codes :
   -
     code : |1+
      CLZF_GenDataMSSQL est une Classe
      	herite de CLZF_GenData
      fin
     type : 131072
  procedures :
   -
     name : Constructeur
     procedure_id : 1474462401575814921
     type_code : 27
     code : |1+
      procédure Constructeur(OlGen_p est un ClZF_GenCodeFic)
      ancetre.constructeur(OlGen_p)
     type : 589824
   -
     name : Destructeur
     procedure_id : 1474462401575880457
     type_code : 28
     code : |1+
      procédure Destructeur()
     type : 655360
   -
     name : sRubSqlDeTypeHF
     procedure_id : 1474468380170634330
     type_code : 12
     code : |1+
      procedure globale sRubSqlDeTypeHF(nType_p est un entier, nTaille_p est un entier = 0)<metier>:chaine
      
      sRetour est une chaîne
      selon nType_p
      	CAS hRubBinaire
      //		stRubHF_Tmp:sType = "Binaire"
      		sRetour = "BINARY"
      		
      //		SI PAS stRubSQL_Tmp:nCodeType DANS (173) ALORS
      //			bTypeIncompatible = Vrai
      //		FIN
      		
      	CAS hRubBooléen
      //		stRubHF_Tmp:sType = "Booléen"
      		sRetour = "BIT"
      		
      //		SI PAS stRubSQL_Tmp:nCodeType DANS (104) ALORS
      //			bTypeIncompatible = Vrai
      //		FIN
      		
      	CAS hRubCaractère
      //		stRubHF_Tmp:sType = "Caractère"
      		sRetour = "CHAR(" + nTaille_p + ")"
      		
      //		SI PAS stRubSQL_Tmp:nCodeType DANS (175,167) ALORS
      //			bTypeIncompatible = Vrai
      //		FIN
      //		SI stRubHF_Tmp.nTaille <> stRubSQL_Tmp.nTaille ALORS
      //			bTypeIncompatible = Vrai
      //		FIN
      //		
      //	CAS hRubDate6
      //		stRubHF_Tmp:sType			= "Date au format AAMMJJ"
      //		stCompRub:bTypeHFInterdit	= Vrai
      //		
      		//SI PAS stR_RubSQL_Tmp:nCodeType DANS () ALORS
      		//	bTypeIncompatible = Vrai
      		//FIN
      		
      	CAS hRubDate8
      //		stRubHF_Tmp:sType = "Date au format AAAAMMJJ"
      		sRetour = "DATE"			//*
      		
      //		SI PAS stRubSQL_Tmp:nCodeType DANS (40) ALORS
      //			bTypeIncompatible = Vrai
      //		FIN
      		
      		//			//Pour les dates qui ont une contrainte chaine vide, on met des simple quote comme en HF
      		//			si stRubSQL_Tmp.bContrainteDefaut_SQL et stRubSQL_Tmp.sValDefaut=""  ALORS
      		//				stRubSQL_Tmp.sValDefaut = "''"
      		//			FIN
      		
      		
      	CAS hRubDateHeure
      //		stRubHF_Tmp:sType = "Date/Heure"
      		sRetour = "Datetime2"		//*
      		
      //		SI PAS stRubSQL_Tmp:nCodeType DANS (61,42) ALORS
      //			bTypeIncompatible = Vrai
      //		FIN
      		
      		//			//Pour les dates qui ont une contrainte chaine vide, on met des simple quote comme en HF
      		//			SI stRubSQL_Tmp.bContrainteDefaut_SQL ET stRubSQL_Tmp.sValDefaut="" ALORS
      		//				stRubSQL_Tmp.sValDefaut = "'00000000000000000'"
      		//			FIN
      		
      	CAS hRubDurée
      //		stRubHF_Tmp:sType = "Durée"
      		sRetour = "Datetime2"		//*
      		
      //		SI PAS stRubSQL_Tmp:nCodeType DANS (61,42) ALORS
      //			bTypeIncompatible = Vrai
      //		FIN
      		
      		//			//Pour les dates qui ont une contrainte chaine vide, on met des simple quote comme en HF
      		//			SI stRubSQL_Tmp.bContrainteDefaut_SQL ET stRubSQL_Tmp.sValDefaut="" ALORS
      		//				stRubSQL_Tmp.sValDefaut = "''"
      		//			FIN
      		
      	CAS hRubEntier1
      //		stRubHF_Tmp:sType = "Entier sur 1 octet"
      		sRetour = "smallint"
      		
      //		SI PAS stRubSQL_Tmp:nCodeType DANS (52) ALORS
      //			bTypeIncompatible = Vrai
      //		FIN
      		
      	CAS hRubEntier2
      //		stRubHF_Tmp:sType = "Entier sur 2 octets"
      		sRetour = "smallint"
      		
      //		SI PAS stRubSQL_Tmp:nCodeType DANS (52) ALORS
      //			bTypeIncompatible = Vrai
      //		FIN
      		
      	CAS hRubEntier4
      //		stRubHF_Tmp:sType = "Entier sur 4 octets"
      		sRetour = "int"
      		
      //		SI PAS stRubSQL_Tmp:nCodeType DANS (56) ALORS
      //			bTypeIncompatible = Vrai
      //		FIN
      		
      	CAS hRubEntier8
      //		stRubHF_Tmp:sType = "Entier sur 8 octets"
      		sRetour = "bigint"
      //		stCompRub:bTypeHFDeprecie = Vrai
      //		
      //		SI PAS stRubSQL_Tmp:nCodeType DANS (127) ALORS
      //			bTypeIncompatible = Vrai
      //		FIN
      		
      	CAS hRubEntierNonSigné1
      //		stRubHF_Tmp:sType = "Entier non signé sur 1 octet"
      		sRetour = "tinyint"
      		//stCompRub:bTypeHFInterdit = Vrai
      //		
      //		SI PAS stRubSQL_Tmp:nCodeType DANS (48) ALORS
      //			bTypeIncompatible = Vrai
      //		FIN
      		
      	CAS hRubEntierNonSigné2
      //		stRubHF_Tmp:sType = "Entier non signé sur 2 octets"
      		sRetour = "INT"
      //		stCompRub:bTypeHFInterdit = Vrai
      //		
      //		SI PAS stRubSQL_Tmp:nCodeType DANS (52) ALORS
      //			bTypeIncompatible = Vrai
      //		FIN
      		
      	CAS hRubEntierNonSigné4
      //		stRubHF_Tmp:sType = "Entier non signé sur 4 octets"
      		sRetour = "int"
      //		stCompRub:bTypeHFInterdit = Vrai
      //		
      //		SI PAS stRubSQL_Tmp:nCodeType DANS (56) ALORS
      //			bTypeIncompatible = Vrai
      //		FIN
      		
      	CAS hRubEntierNonSigné8
      //		stRubHF_Tmp:sType = "Entier non signé sur 8 octets"
      		sRetour = "bigint"
      //		stCompRub:bTypeHFInterdit = Vrai
      //		
      //		SI PAS stRubSQL_Tmp:nCodeType DANS (127) ALORS
      //			bTypeIncompatible = Vrai
      //		FIN
      		
      	CAS hRubHeure
      //		stRubHF_Tmp:sType = "Heure"
      		sRetour = "Time(0)"
      		
      //		SI PAS stRubSQL_Tmp:nCodeType DANS (41) ALORS
      //			bTypeIncompatible = Vrai
      //		FIN
      //		
      		//			//Pour les heures qui ont une contrainte chaine vide, on met des simple quote comme en HF.
      		//			SI stRubSQL_Tmp.bContrainteDefaut_SQL et stRubSQL_Tmp.sValDefaut = "" ALORS
      		//				stRubSQL_Tmp.sValDefaut = "''"
      		//			FIN
      		
      	CAS hRubIDAuto
      //		stRubHF_Tmp:sType = "Identifiant automatique (8 octets)"
      		sRetour= "bigint"
      //		stCompRub:bTypeHFDeprecie = Vrai
      //		
      //		SI PAS stRubSQL_Tmp:nCodeType DANS (127) ALORS
      //			bTypeIncompatible = Vrai
      //		FIN
      //		
      //		//Pour les identifiants auto, on a pas de valeurs par défaut sous SQL. On reprend la valeur par défaut tel que paramétrée dans l'analyse
      //		stRubSQL_Tmp.sValDefaut = "0"
      //		
      		
      	CAS hRubIDAuto4
      //		stRubHF_Tmp:sType = "Identifiant automatique (4 octets)"
      		sRetour = "int"
      		
      //		SI PAS stRubSQL_Tmp:nCodeType DANS (56) ALORS
      //			bTypeIncompatible = Vrai
      //		FIN
      //		
      //		//Pour les identifiants auto, on a pas de valeurs par défaut sous SQL. On reprend la valeur par défaut tel que paramétrée dans l'analyse
      //		stRubSQL_Tmp.sValDefaut = "0"
      //		
      		
      	CAS hRubImage
      //		stRubHF_Tmp:sType = "Image"
      		sRetour = "IMAGE"
      		
      //		SI PAS stRubSQL_Tmp:nCodeType DANS (24) ALORS
      //			bTypeIncompatible = Vrai
      //		FIN
      		
      //	CAS hRubInvalide
      //		SI stCompRub.nModeActionRubrique = cstModeGestionRub_Supp ALORS
      //			stRubHF_Tmp:sType = "A supprimer"
      //		SINON
      //			stRubHF_Tmp:sType = "Invalide"
      //		FIN
      //		
      //		stCompRub:bTypeHFInterdit = Vrai
      //		
      		//SI PAS stR_RubSQL_Tmp:nCodeType DANS () ALORS
      		//	bTypeIncompatible = Vrai
      		//FIN
      		
      	CAS hRubMémoBinaire
      //		stRubHF_Tmp:sType = "Mémo binaire"
      		sRetour = "VARBINARY(max)"
      		
      //		SI PAS stRubSQL_Tmp:nCodeType DANS (165,173,34) ALORS
      //			bTypeIncompatible = Vrai
      //		FIN
      //		
      //		SI stRubSQL_Tmp.nTaille <> -1 ALORS
      //			bTypeIncompatible = Vrai
      //		FIN
      		
      		//			//Pour les champs 'mémo' n'ont pas de valeur par défaut, on reprend la valeur proposé tel que représenté sous HF.
      		//			SI stRubSQL_Tmp.bContrainteDefaut_SQL ET stRubSQL_Tmp.sValDefaut = "" ALORS
      		//				stRubSQL_Tmp.sValDefaut = "''"
      		//			FIN
      		
      	CAS hRubMémoBinaire4
      //		stRubHF_Tmp:sType = "Mémo binaire (4 octets)"
      		sRetour = "VARBINARY(max)"
      		
      //		SI PAS stRubSQL_Tmp:nCodeType DANS (165,173,34) ALORS
      //			bTypeIncompatible = Vrai
      //		FIN
      //		
      //		SI stRubSQL_Tmp.nTaille <> -1 ALORS
      //			bTypeIncompatible = Vrai
      //		FIN
      		
      	CAS hRubMémoTexte
      //		stRubHF_Tmp:sType = "Mémo texte"
      		sRetour = "Text"
      		
      //		SI PAS stRubSQL_Tmp:nCodeType DANS (35) ALORS
      //			bTypeIncompatible = Vrai
      //		FIN
      		
      		//			//Pour les champs 'mémo' n'ont pas de valeur par défaut, on reprend la valeur proposé tel que représenté sous HF.
      		//			SI stRubSQL_Tmp.bContrainteDefaut_SQL et stRubSQL_Tmp.sValDefaut = "" ALORS
      		//				stRubSQL_Tmp.sValDefaut = "''"
      		//			FIN
      		
      	CAS hRubMémoUnicode
      //		stRubHF_Tmp:sType = "Mémo texte Unicode"
      		sRetour = "nText"
      //		stCompRub:bTypeHFDeprecie = Vrai
      //		
      //		SI PAS stRubSQL_Tmp:nCodeType DANS (99) ALORS
      //			bTypeIncompatible = Vrai
      //		FIN
      		
      		//			//Pour les champs 'mémo' n'ont pas de valeur par défaut, on reprend la valeur proposé tel que représenté sous HF.
      		//			SI stRubSQL_Tmp.bContrainteDefaut_SQL et stRubSQL_Tmp.sValDefaut = "" ALORS
      		//				stRubSQL_Tmp.sValDefaut = "''"
      		//			FIN
      		
      	CAS hRubMonétaire
      //		stRubHF_Tmp:sType = "Monétaire"
      		sRetour = "Money"
      		
      //		SI PAS stRubSQL_Tmp:nCodeType DANS (60) ALORS
      //			bTypeIncompatible = Vrai
      //		FIN
      		
      //	CAS hRubNumEnr
      //		stRubHF_Tmp:sType			= "Numéro d'enregistrement"
      //		stCompRub:bTypeHFInterdit	= Vrai
      		
      		//SI PAS stR_RubSQL_Tmp:nCodeType DANS () ALORS
      		//	bTypeIncompatible = Vrai
      		//FIN
      		
      	CAS hRubNumérique
      //		stRubHF_Tmp:sType = "Numérique"
      		sRetour = "Float(" + nTaille_p + ")"		// !!!!
      //		stCompRub:bTypeHFInterdit = Vrai
      //		
      //		SI PAS stRubSQL_Tmp:nCodeType DANS (108,59) ALORS
      //			bTypeIncompatible = Vrai
      //		FIN
      //		SI stRubHF_Tmp.nTaille <> stRubSQL_Tmp.nTaille ALORS
      //			bTypeIncompatible = Vrai
      //		FIN
      		
      	CAS hRubRéel4
      //		stRubHF_Tmp:sType = "Réel sur 4 octets"
      		sRetour = "Real"
      		
      //		SI PAS stRubSQL_Tmp:nCodeType DANS (59) ALORS
      //			bTypeIncompatible = Vrai
      //		FIN
      		
      	CAS hRubRéel8
      //		stRubHF_Tmp:sType = "Réel sur 8 octets"
      		sRetour = "Float"
      //		//stCompRub:sCodeDeclarationVar_Sql += "Float(" + stR_RubHF_Tmp.sTaille + ")"
      //		stCompRub:bTypeHFDeprecie = Vrai
      //		
      //		SI PAS stRubSQL_Tmp:nCodeType DANS (62) ALORS
      //			bTypeIncompatible = Vrai
      //		FIN
      //		SI stRubHF_Tmp.nTaille <> stRubSQL_Tmp.nTaille ALORS
      //			bTypeIncompatible = Vrai
      //		FIN
      		
      	CAS hRubRéelTurbo
      //		stRubHF_Tmp:sType = "Réel turbo"
      		sRetour = "Real"
      //		stCompRub:bTypeHFDeprecie = Vrai
      		
      		//SI PAS stR_RubSQL_Tmp:nCodeType DANS () ALORS
      		//	bTypeIncompatible = Vrai
      		//FIN
      		
      	CAS hRubTexte
      //		stRubHF_Tmp:sType = "Texte"
      		sRetour = "Varchar(" + nTaille_p + ")"
      		
      //		SI PAS stRubSQL_Tmp:nCodeType DANS (175,167) ALORS
      //			bTypeIncompatible = Vrai
      //		FIN
      //		SI stRubHF_Tmp.nTaille <> stRubSQL_Tmp.nTaille ALORS
      //			bTypeIncompatible = Vrai
      //		FIN
      		
      		
      	CAS hRubTexteUnicode
      //		stRubHF_Tmp:sType = "Texte unicode"
      		sRetour = "nVarchar(" + nTaille_p + ")"
      //		stCompRub:bTypeHFDeprecie = Vrai
      //		
      //		SI PAS stRubSQL_Tmp:nCodeType DANS (239,231) ALORS
      //			bTypeIncompatible = Vrai
      //		FIN
      //		SI stRubHF_Tmp.nTaille <> stRubSQL_Tmp.nTaille / 2 ALORS
      //			bTypeIncompatible = Vrai
      //		FIN
      //		
      		
      	AUTRE CAS
      		ExceptionDéclenche(1, "Type non défini : [%nType_p%]")
      FIN
      
      renvoyer sRetour
      
      
     type : 458752
   -
     name : stGenSQLRub
     procedure_id : 1474472812576933184
     type_code : 12
     code : |1-
      procedure stGenSQLRub(sRub_p est une chaine, bCreeTable_p est un booléen, stRubSql_p est un CLZF_GenData.STR_RubSQL)<metier>:CLZF_GenData.STR_RubSQL
      
      
      stRetour est un CLZF_GenData.STR_RubSQL
      stInfoRub est un ClZF_GenCodeFic.STR_DefRub
      
      stRetour.nTypeAlterRub = cstTypeAlterRub_RAS
      
      si :m_oCOlGen.m_aRub[sRub_p]..vide et stRubSql_p.stype <> "" et pas sRub_p = :m_oCOlGen.p_sNomRubId ALORS
      	stRetour.nTypeAlterRub = CLZF_GenData.cstTypeAlterRub_SuppRub
      sinon
      	stInfoRub = :m_oCOlGen.m_aRub[sRub_p]
      	
      	//Récupération du type
      	stRetour.sType = sRubSqlDeTypeHF(stInfoRub.nTypeRubHF, stInfoRub.nTaille)
      FIN
      
      //Est on en création de table ?
      si bCreeTable_p alors
      	stRetour.nTypeAlterRub = CLZF_GenData.cstTypeAlterRub_CreeTable
      SINON
      	//Non :
      	//La rubrique existe t elle ?
      	SI PAS :m_oCOlGen.m_aRub[sRub_p]..Vide ET stRubSql_p.sType = "" ALORS
      		stRetour.nTypeAlterRub = CLZF_GenData.cstTypeAlterRub_CreeRub
      	FIN
      FIN
      
      si stRetour.nTypeAlterRub = cstTypeAlterRub_RAS ALORS
      	si pas bRubCompatible(stInfoRub.nTypeRubHF, stRubSql_p.sType) ou ...
      			stInfoRub.nTaille <> stRubSql_p.nTaille ou ...
      			stInfoRub.bNullable <> stRubSql_p.bEstNullable alors
      			
      		stRetour.nTypeAlterRub = CLZF_GenData.cstTypeAlterRub_ModRub
      	FIN
      FIN
      
      
      si pas stRetour.nTypeAlterRub dans(CLZF_GenData.cstTypeAlterRub_CreeTable, CLZF_GenData.cstTypeAlterRub_RAS) ALORS
      	stRetour.sCodeSQL = "ALTER TABLE [%:m_oCOlGen.p_sNomTable%] "
      FIN
      
      selon stRetour.nTypeAlterRub
      	CAS CLZF_GenData.cstTypeAlterRub_SuppRub
      		stRetour.sCodeSQL += "DROP COLUMN [%sRub_p%]"
      	CAS CLZF_GenData.cstTypeAlterRub_CreeTable
      		stRetour.sCodeSQL += sRub_p
      	CAS CLZF_GenData.cstTypeAlterRub_CreeRub
      		stRetour.sCodeSQL += "ADD [%sRub_p%]"
      	CAS CLZF_GenData.cstTypeAlterRub_ModRub
      		stRetour.sCodeSQL += "ALTER COLUMN [%sRub_p%]"
      		
      	AUTRE CAS
      		
      FIN
      
      SI PAS stRetour.nTypeAlterRub DANS(CLZF_GenData.cstTypeAlterRub_SuppRub, CLZF_GenData.cstTypeAlterRub_RAS) ALORS
      	stRetour.sCodeSQL += " " + stRetour.sType
      	
      	si pas stInfoRub.bNullable ALORS
      		stRetour.sCodeSQL += " NOT"
      	FIN
      	stRetour.sCodeSQL += " NULL"
      	
      	
      	//Génération du code de contrainte par défaut
      	sNomDF est une chaîne
      	sNomDF = sNomRelDF(:m_oCOlGen.p_sNomTable, sRub_p)
      	sValDef est une chaîne = stInfoRub.sValDef
      	
      	SI ::bProteger(stInfoRub.nTypeRubHF) ALORS
      		sValDef = "'" + sValDef + "'"
      	FIN
      	
      	SI stRetour.nTypeAlterRub = CLZF_GenData.cstTypeAlterRub_CreeTable ALORS
      		
      		SI PAS stInfoRub.bNullable ALORS
      			stRetour.sCodeSQL += " CONSTRAINT [%sNomDF%] DEFAULT ([%sValDef%])"
      		FIN
      		
      	sinon
      		
      		si stRetour.nTypeAlterRub dans (CLZF_GenData.cstTypeAlterRub_SuppRub, CLZF_GenData.cstTypeAlterRub_ModRub) Ou ...	//Modification rubrique
      				stInfoRub.bNullable ET stRubSql_p.sNomContrainteDef <> "" ALORS												//Contrainte défaut à supprimer
      			
      			stRetour.sCodeDropDef = [
      				ALTER TABLE [%:m_oCOlGen.p_sNomTable%]
      					DROP CONSTRAINT [%stRubSql_p.sNomContrainteDef%]
      				]
      		FIN
      		
      		si pas stInfoRub.bNullable et stRubSql_p.sNomContrainteDef = "" ou ...	//Contrainte défaut manquante
      				stRetour.nTypeAlterRub DANS (CLZF_GenData.cstTypeAlterRub_CreeRub, CLZF_GenData.cstTypeAlterRub_ModRub) alors
      			
      			stRetour.sCodeAddDef = [
      				ALTER TABLE [%:m_oCOlGen.p_sNomTable%]
      					ADD CONSTRAINT [%sNomDF%] DEFAULT ([%sValDef%]) FOR [[%sRub_p%]]
      				]
      		FIN
      	FIN
      //	si pas stInfoRub.bNullable et :m_oCOlGen.m_aRub[sRub_p]..vide alors
      //		sValDef est une chaîne = stInfoRub.sValDef
      //		si ::bProteger(stInfoRub.nTypeRubHF) ALORS
      //			sValDef = "'" + sValDef + "'"
      //		FIN
      //		sNomDF est une chaîne
      //		sNomDF = sNomRelDF(:m_oCOlGen.p_sNomTable, sRub_p)
      //		
      //		si stRetour.nTypeAlterRub = CLZF_GenData.cstTypeAlterRub_CreeTable alors
      //			stRetour.sCodeSQL += " CONSTRAINT [%sNomDF%] DEFAULT ([%sValDef%]) FOR [[%sRub_p%]]"
      //		sinon
      //			stRetour.sCodeDropDef = [
      //			ALTER TABLE [%:m_oCOlGen.p_sNomTable%]
      //				DROP CONSTAINT [%stRubSql_p.sNomContrainteDef%]
      //			]
      //			
      //			stRetour.sCodeAddDef = [
      //			ALTER TABLE [%:m_oCOlGen.p_sNomTable%]
      //				CONSTRAINT [%sNomDF%] DEFAULT ([%sValDef%]) FOR [[%sRub_p%]]
      //			]
      //		FIN
      //	FIN
      	
      	
      	
      
      	//Génération du code de contrainte FK
      	stRel_tmp est un ClZF_GenCodeFic.STR_Rel
      	si :m_oCOlGen.m_aPK_de_FK[sRub_p]..Occurrence > 0 alors
      		stRel_tmp = :m_oCOlGen.m_aPK_de_FK[sRub_p]
      		
      		stRetour.sRefTablePK = stRel_tmp.sTablePK
      		stRetour.sRefRubIdPK = stRel_tmp.sRubriquePK
      	fin
      	
      	SI stRetour.sRefTablePK <> "" ALORS
      		
      		sNomFK est une chaîne
      		sNomFK = ::sNomRelFK(:m_oCOlGen.p_sNomTable, sRub_p, stRetour.sRefTablePK, stRetour.sRefRubIdPK)
      		
      		SI stRetour.nTypeAlterRub DANS(CLZF_GenData.cstTypeAlterRub_CreeTable) ALORS
      			stRetour.sCodeKey = "CONSTRAINT [%sNomFK%] FOREIGN KEY ([%sRub_p%]) REFERENCES [%stRetour.sRefTablePK%] ([%stRetour.sRefRubIdPK%]) ON DELETE NO ACTION ON UPDATE NO ACTION"
      		sinon
      			stRetour.sCodeKey = [
      				ALTER TABLE [[%:m_oCOlGen.p_sNomTable%]] WITH CHECK ADD CONSTRAINT [[%sNomFK%]] FOREIGN KEY([[%sRub_p%]])
      				REFERENCES [[%stRetour.sRefTablePK%]] ([[%stRetour.sRefRubIdPK%]]) ON DELETE NO ACTION ON UPDATE NO ACTION
      				]
      		FIN
      	FIN
      FIN
      
      renvoyer stRetour
     type : 458752
   -
     name : GetDefRubSQL
     procedure_id : 1475212517645710165
     type_code : 12
     code : |1+
      // Résumé : <indiquez ici ce que fait la procédure>
      // Syntaxe :
      //[ <Résultat> = ] GetDefRubSQL ()
      //
      // Paramètres :
      //	Aucun
      
      // Valeur de retour :
      // 	tableau associatif (STR_RubSQL) : <indiquez ici le rôle de la valeur de retour>
      //
      // Exemple :
      // <Indiquez ici un exemple d'utilisation>
      //
      procédure GetDefRubSQL()<metier>:tableau associatif de CLZF_GenData.STR_RubSQL
      
      
      sReq		est une chaîne
      sdDefTbl	est une source de données
      stRub		est un CLZF_GenData.STR_RubSQL
      aRetour		est un tableau associatif de CLZF_GenData.STR_RubSQL
      
      
      sReq = [
      
      SELECT
      --	sys.columns.column_id AS ObjectID_RubriqueDansTable,
      --	columns.object_id AS ID_Table,
      --	tables.name AS NomTable,
      	columns.NAME AS Rubrique,
      --	columns.system_type_id AS CodeType,
      	types.NAME AS Type,
      	columns.max_length AS Taille,
      	columns.is_nullable AS EstNullable,
      
      	default_constraints.name as NomContainteDef,
      	NULLIF(default_constraints.definition, '(NULL)') As ValeurDefaut,	--Si on a déja une contrainte, qui met 'NULL' par défaut, on considère qu'il n'y a pas de contrainte (on généralise le traitement)
      			
      	CASE WHEN TmpInfoIndex.object_id IS NULL
      		THEN 0
      		ELSE 1
      	END AS EstIndex,
      	isnull(TmpInfoIndex.is_unique, 0) AS EstIndexUnique,
      			
      	CASE WHEN tmpColFullText.object_id IS NULL
      		THEN 0
      		ELSE 1
      	END AS EstFullText,
      			
      	CASE WHEN tmpColCleEtrangere.ID_CleEtrangere IS NULL
      		THEN 0
      		ELSE 1
      	END AS EstCleEtrangere,
      	tmpColCleEtrangere.Nom_Table_CleReferencee,
      	tmpColCleEtrangere.Nom_CleReference
      		
      		
      FROM sys.columns
      	INNER JOIN sys.tables ON (tables.object_id = columns.object_id)
      	LEFT OUTER JOIN sys.types ON (types.system_type_id = columns.system_type_id)
      	LEFT OUTER JOIN sys.default_constraints ON (default_constraints.parent_object_id = columns.object_id
      		AND default_constraints.parent_column_id = columns.column_id)
      		
      -- Rubrique index ?
      LEFT OUTER JOIN (
      		
      	SELECT 
      		indexes.object_id,
      		index_columns.index_id,
      		MAX(index_columns.column_id) AS column_id,
      		max(cast(indexes.is_unique as tinyint)) AS is_unique
      			
      	FROM sys.index_columns
      		INNER JOIN sys.indexes ON (indexes.index_id = index_columns.index_id
      			AND indexes.object_id = index_columns.object_id)
      			
      	WHERE index_columns.is_included_column = 0
      		
      GROUP BY indexes.object_id,
      	index_columns.index_id
      	HAVING count(*) = 1
      		
      ) AS TmpInfoIndex
      	ON (TmpInfoIndex.object_id = columns.object_id AND TmpInfoIndex.column_id = columns.column_id)
      		
      -- Rubrique full text ?
      LEFT OUTER JOIN (
      		
      	SELECT
      		fulltext_index_columns.object_id,
      		fulltext_index_columns.column_id
      	FROM sys.fulltext_index_columns
      		
      ) AS tmpColFullText 
      	ON (tmpColFullText.object_id = columns.object_id AND tmpColFullText.column_id = columns.column_id)
      		
      -- Rubrique clé étrangère ?
      LEFT OUTER JOIN (
      		
      	SELECT
      		foreign_key_columns.parent_column_id AS ID_CleEtrangere,
      		foreign_key_columns.parent_object_id AS ID_TableEtrangere,
      		object_name(foreign_key_columns.parent_object_id) AS Nom_Table_CleEtrangere,
      		ColPrim.name AS Nom_CleEtrangere,
      				
      		foreign_key_columns.referenced_column_id AS ID_CleReference,
      		foreign_key_columns.referenced_object_id AS ID_TableReferencee,
      		object_name(foreign_key_columns.referenced_object_id) AS Nom_Table_CleReferencee,
      		colEtrangere.name AS Nom_CleReference
      			
      	FROM sys.foreign_key_columns
      			
      	INNER JOIN sys.columns AS colEtrangere 
      		ON (colEtrangere.object_id = foreign_key_columns.parent_object_id and colEtrangere.column_id = foreign_key_columns.parent_column_id)
      			
      	INNER JOIN sys.columns AS ColPrim 
      		ON (ColPrim.object_id = foreign_key_columns.referenced_object_id and ColPrim.column_id = foreign_key_columns.referenced_column_id) 
      		
      ) AS tmpColCleEtrangere
      	ON (tmpColCleEtrangere.ID_CleEtrangere = sys.columns.column_id 
      		AND tmpColCleEtrangere.ID_TableEtrangere = columns.object_id)
      		
      where sys.tables.name = '[%:m_oCOlGen.p_sNomTable%]'
      ]
      goApp.Rsql(sdDefTbl, sReq)
      
      
      pour tout sdDefTbl
      	VariableRAZ(stRub)
      	// ???				EstIndex		EstFullText	EstCleEtrangere		
      	//nCodeType		est un entier
      	stRub.sType				= sdDefTbl.Type
      	stRub.nTaille			= sdDefTbl.Taille
      	stRub.bEstNullable		= sdDefTbl.EstNullable
      	stRub.sValeurDefaut		= sdDefTbl.ValeurDefaut
      	stRub.bEstIndexUnique	= sdDefTbl.EstIndexUnique
      	stRub.sRefTablePK		= sdDefTbl.Nom_Table_CleReferencee
      	stRub.sRefRubIdPK		= sdDefTbl.Nom_CleReference
      	stRub.sNomContrainteDef	= sdDefTbl.NomContainteDef
      	
      	aRetour[sdDefTbl.Rubrique] = stRub
      FIN
      
      renvoyer aRetour
      
      
      
     type : 458752
   -
     name : sNomRelFK
     procedure_id : 1475218633680694444
     type_code : 12
     code : |1+
      procedure globale sNomRelFK(sTableFK_p, sRubriqueFK_p, sTablePK_p, sRubriquePK_p)<metier>:chaine
      
      renvoyer gauche("FK_[%sTableFK_p%]_[%sRubriqueFK_p%]_[%sTablePK_p%]_[%sRubriquePK_p%]", 128)
      
     type : 458752
   -
     name : sNomRelDF
     procedure_id : 1475955650095043915
     type_code : 12
     code : |1+
      procedure globale sNomRelDF(sTable_p, sRubrique_p)<metier>:chaine
      
      renvoyer "DF_[%sTable_p%]_[%sRubrique_p%]"
     type : 458752
   -
     name : bRubCompatible
     procedure_id : 1476194235531916167
     type_code : 12
     code : |1+
      procedure globale  bRubCompatible(nTypeHF_p est un entier, sTypeSQL_P est une chaîne)<metier>:booleen
      
      bRetour est un booléen
      selon majuscule(sTypeSQL_P)
      	CAS "BINARY"
      		bRetour = nTypeHF_p dans (hRubBinaire)
      	CAS "BIT"
      		bRetour = nTypeHF_p DANS (hRubBooléen)
      		
      	CAS "CHAR"
      		bRetour = nTypeHF_p DANS (hRubCaractère)
      		
      	CAS "DATE"
      		bRetour = nTypeHF_p DANS (hRubDate8)
      		
      	CAS "DAYETIME2"
      		bRetour = nTypeHF_p DANS (hRubDateHeure, hRubDurée)
      		
      	CAS "SMALLINT"
      		bRetour = nTypeHF_p DANS (hRubEntier1, hRubEntier2)
      		
      	CAS "INT"
      		bRetour = nTypeHF_p DANS (hRubEntier4, hRubEntierNonSigné2, hRubIDAuto4)
      		
      	CAS "BIGINT"
      		bRetour = nTypeHF_p DANS (hRubEntier8, hRubEntierNonSigné8, hRubEntierNonSigné4, hRubIDAuto)
      		
      	CAS "TINYINT"
      		bRetour = nTypeHF_p DANS (hRubEntierNonSigné1)
      		
      	CAS "TIME"
      		bRetour = nTypeHF_p DANS (hRubHeure)
      		
      	CAS "IMAGE"
      		bRetour = nTypeHF_p DANS (hRubImage)
      		
      	CAS "VARBINARY"
      		bRetour = nTypeHF_p DANS (hRubMémoBinaire, hRubMémoBinaire4)
      		
      	CAS "TEXT"
      		bRetour = nTypeHF_p DANS (hRubMémoTexte)
      		
      	CAS "NTEXT"
      		bRetour = nTypeHF_p DANS (hRubMémoUnicode)
      		
      	CAS "MONEY"
      		bRetour = nTypeHF_p DANS (hRubMonétaire)
      		
      /*	CAS hRubNumérique
      		sRetour = "Float(" + nTaille_p + ")"		// !!!!<§cs:10§>
      		bRetour = nTypeHF_p DANS ()<§cs:10§>
      		*/
      	CAS "REAL"
      		bRetour = nTypeHF_p DANS (hRubRéel4, hRubRéelTurbo)
      		
      	CAS "FLOAT"
      		bRetour = nTypeHF_p DANS (hRubRéel8)
      		
      	CAS "VARCHAR"
      		bRetour = nTypeHF_p DANS (hRubTexte)
      		
      	CAS "NVARCHAR"
      		bRetour = nTypeHF_p DANS (hRubTexteUnicode)
      		
      	AUTRE CAS
      		//ExceptionDéclenche(1, "Type non défini : [%sTypeSQL_P%]")
      		bRetour = faux
      FIN
      
      renvoyer bRetour
      
      
     type : 458752
   -
     name : GenCodeDiff
     procedure_id : 1524488917916055523
     type_code : 12
     code : |1+
      // Redéfinition de la méthode CLZF_GenData.GenCodeDiff
      PROCÉDURE  GenCodeDiff():Vide
      
      
      sRub			est une chaîne
      
      sCode			est une chaîne
      stRubSql		est un CLZF_GenData.STR_RubSQL
      aStRubSQL		est un tableau associatif de CLZF_GenData.STR_RubSQL
      aRubs			est un tableau associatif de CLZF_GenData.STR_RubSQL
      bCreationTbl	est un booléen
      sIndicateurPK	est une chaîne
      
      
      aRubs = :GetDefRubSQL()
      
      
      SI aRubs..Occurrence = 0 ALORS
      	bCreationTbl = Vrai
      SINON
      	bCreationTbl = Faux
      FIN
      
      
      
      POUR TOUT sRub DE :m_oColGen.aLstRubs()
      	SI aRubs[sRub]..Vide ALORS
      		VariableRAZ(stRubSql)
      	SINON
      		stRubSql = aRubs[sRub]
      	FIN
      	aStRubSQL[sRub]	= :stGenSQLRub(sRub, bCreationTbl, stRubSql)
      FIN
      
      
      
      SI bCreationTbl ALORS
      	//Table en création :
      	sTypeId est une chaîne
      	
      	//Récupération du type de la rubrique
      	sTypeId = CLZF_GenDataMSSQL.sRubSqlDeTypeHF(:m_oColGen.p_nTypeHfRubId)
      	
      	//Ajout de l'auto incrément si le type est définit comme tel
      	SI :m_oColGen.p_nTypeHfRubId DANS (hRubIDAuto4, hRubIDAuto) ALORS
      		sIndicateurPK = "identity(1, 1)"
      	FIN
      	
      	//Définition de la rubrique de la colonne ID.
      	sCode += TAB + "[%:m_oColGen.p_sNomRubId%] [%sTypeId%] not null [%sIndicateurPK%]," + RC
      	
      	//Rénération de la définition de toutes les rubriques.
      	POUR TOUT stRubSql, sRub de aStRubSQL
      		sCode += TAB + stRubSql.sCodeSQL + "," + RC
      	FIN
      	
      	sCode += TAB + "CONSTRAINT PK_[%:m_oColGen.p_sNomTable%]_[%:m_oColGen.p_sNomRubId%] PRIMARY KEY NONCLUSTERED ([%:m_oColGen.p_sNomRubId%])"
      	
      	POUR TOUT stRubSql, sRub de aStRubSQL
      		SI stRubSql.sCodeKey <> "" ALORS
      			sCode += "," + RC + TAB + stRubSql.sCodeKey
      		FIN
      	FIN
      	
      	
      	sCode = [
      	CREATE TABLE [%:m_oColGen.p_sNomTable%] (
      	[%sCode%]
      	)
      	
      	]
      SINON
      	
      	POUR TOUT stRubSql, sRub de aStRubSQL
      		SI sRub <> :m_oColGen.p_sNomRubId _ET_ stRubSql.nTypeAlterRub <> CLZF_GenData.cstTypeAlterFK_RAS ALORS
      			sCode += [RC + RC] + "--" + sRub
      			sCode += RC + stRubSql.sCodeDropDef
      			sCode += RC + stRubSql.sCodeSQL
      			sCode += RC + stRubSql.sCodeAddDef
      		FIN
      	FIN
      	
      	POUR TOUT stRubSql, sRub de aStRubSQL
      		SI sRub <> :m_oColGen.p_sNomRubId ALORS
      			sCode += [RC + RC] + stRubSql.sCodeKey
      		FIN
      	FIN
      	
      FIN
      
      
      :m_sCode = sCode
     type : 458752
  procedure_templates : []
  property_templates : []
 code_parameters :
  internal_properties : BwAAAAcAAAA6ih3UbgNXHwTtiPSFUEj+2fi/m7v4QV2rqidAupM=
  original_name : Classe1
resources :
 string_res :
  identifier : 0x147657b90091718d
  internal_properties : BwAAAAcAAAAnMYFQ1bL/vz9ehh7L22SNNSlIzGTOI8h5F/WtgDNP
custom_note :
 internal_properties : BwAAAAcAAABtB9HWVzrXO2+4NDRVK0vmzaNKrCKqH1DBX30lMmGZ
