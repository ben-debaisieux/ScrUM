#To edit and compare internal_properties, use WINDEV integrated tools.
#Internal properties refer to the properties of controls in windows, reports, etc.
info :
 name : ClZF_GenCodeFic
 major_version : 27
 minor_version : 0
 type : 4
 description : ""
 subtype : 0
class :
 identifier : 0x1408fca4c669569e
 internal_properties : BwAAAAcAAAB2/vstTMCJbS/hlxjFxirSqKvCUuv8YxgpWyl7S3iA
 code_elements :
  type_code : 10
  p_codes :
   -
     code : |1-
      STR_DefRub est une structure
      	nTypeRub				est un entier
      	nTypeRubHF				est un entier
      	
      	bNullable				est un booléen
      	sNomMembre				est une chaîne
      	sNomPropriete			est une chaîne
      	sPrefixe				est une chaîne
      	sNomDeclarationComplet	est une chaîne
      	sNomDeclarationCourt	est une chaîne
      	bVisibleInterface		est un booléen
      	
      	sLibelleRubrique		est une chaîne
      	bVisibleUsr				est un booléen
      	nTaille					est un entier
      	sValDef					est une chaine
      	nTypeCle				est un entier
      	//sMeta					est une chaîne
      	
      	oObj_Parent				est un ClZF_GenCodeFic dynamique
      fin
      
      STR_InfoCol est une Structure
      	sDeclaration		est une chaîne
      	sTableDesti			est une chaîne
      	sCleDesti			est une chaîne
      FIN
      
      STR_Rel est une Structure
      	sNomRel			est une chaine
      	sTablePK		est une chaîne
      	sRubriquePK		est une chaîne
      	sTableFK		est une chaîne
      	sRubriqueFK		est une chaîne
      	nTypeRel		est un entier
      FIN
      
      
      STR_DescRub est une structure
      	sValMin		est une chaîne
      	sValMax		est une chaîne
      	nPctNull	est un entier
      	sMeta		est une chaîne
      	sGrpExclu	est une chaîne
      FIN
      
      STR_DescFic est une structure
      	bTopLs		est un booléen
      	bTopHisto	est un booléen
      	nNbLigneGen	est un entier
      	taRubs		est un tableau associatif de STR_DescRub
      FIN
      
      //////////////////////////////////////////////////////////////////////////////////////////////
      
      ClZF_GenCodeFic est une Classe
      public
      	m_aRub			est un tableau associatif (ccSansCasse) de STR_DefRub
      	m_aCol_Enfant	est un tableau de STR_InfoCol		// a faire : vérifier utilité ?
      	m_aFK_de_PK		est un tableau de str_rel
      	m_aPK_de_FK		est un tableau associatif de str_rel
      	m_stConfigTbl	est un STR_DescFic
      PRIVE
      	m_sNomTable		est une chaîne
      	m_sNomUsage		est une chaîne
      	m_sLibelle		est une chaîne
      	m_sNomRubId		est une chaîne
      	m_bClasseExiste	est un booléen
      	m_bClasseLS		est un booléen
      globale
      public
      	mg_sPrefixeTable est une chaîne ANSI
      fin
      
      constante
      	cstDefRubNum		= 1
      	cstDefRubChaine		= 2
      	cstDefRubObj		= 3
      	
      	cstRelNonDef		= 0
      	cstRelAsso			= 1
      	cstRelAsso_Suf		= "Asso"
      	cstRelAgr			= 2
      	cstRelAgr_Suf		= "Agr"
      	cstRelCompo			= 3
      	cstRelCompo_Suf		= "Compo"
      	
      	cstTypeCleAucune	= 0
      	cstTypeCleUnique	= 1
      	cstTypeCleDoublon	= 2
      	
      	
      	
      fin
     type : 131072
  procedures :
   -
     name : Constructeur
     procedure_id : 1443681465206134430
     type_code : 27
     code : |1+
      procédure Constructeur(local sNomTable_P est une chaîne = "")
      
      :m_sNomTable = sNomTable_P
      :m_sNomUsage = remplace(sNomTable_P, ::mg_sPrefixeTable , "", SansCasse)
      si sNomTable_P <> "" ALORS
      	:m_sLibelle = {sNomTable_P,indFichier}..Libellé
      FIN
      
     type : 589824
   -
     name : Destructeur
     procedure_id : 1443681465206199966
     type_code : 28
     code : |1+
      procédure Destructeur()
      
     type : 655360
   -
     name : aLstRubs
     procedure_id : 1443681465206527646
     type_code : 12
     code : |1-
      // Résumé : <indiquez ici ce que fait la procédure>
      // Syntaxe :
      //[ <Résultat> = ] aLstRubs ()
      //
      // Paramètres :
      //	Aucun
      // Valeur de retour :
      // 	tableau (chaîne ANSI) : <indiquez ici le rôle de la valeur de retour>
      //
      // Exemple :
      // <Indiquez ici un exemple d'utilisation>
      //
      procédure aLstRubs():tableau de chaine
      
      aRetour	est un tableau de chaines
      stTmp	est un STR_DefRub
      sCle	est une chaîne
      
      pour tout element stTmp, sCle de :m_aRub
      	TableauAjoute(aRetour, sCle)
      FIN
      
      
      renvoyer aRetour
     type : 458752
   -
     name : GetInfoRubPrefix
     procedure_id : 1443681465206593182
     type_code : 12
     code : |1+
      // Résumé : <indiquez ici ce que fait la procédure>
      // Syntaxe :
      //[ <Résultat> = ] GetInfoRubPrefix (<nTypeHF_p> est entier)
      //
      // Paramètres :
      //	nTypeHF_p (entier) : <indiquez ici le rôle de nStypeHF_p>
      // Valeur de retour :
      // 	chaîne ANSI : <indiquez ici le rôle de la valeur de retour>
      //
      // Exemple :
      // <Indiquez ici un exemple d'utilisation>
      //
      procédure GetInfoRubPrefix(nTypeHF_p est un entier):chaine
      
      sRetour est une chaîne
      
      selon nTypeHF_p
      	CAS hRubBooléen
      		sRetour = "b"
      	CAS hRubdate6, hRubDate8
      		sRetour = "d"
      	CAS hRubDateHeure
      		sRetour = "dh"
      	CAS hRubEntier1, hRubEntier2, hRubEntier4, hRubEntier8, hRubEntierNonSigné1, hRubEntierNonSigné2, hRubEntierNonSigné4, hRubEntierNonSigné8
      		sRetour = "n"
      	CAS hRubMémoTexte, hRubMémoUnicode, hRubTexte, hRubTexteUnicode
      		sRetour = "s"
      	CAS hRubMonétaire
      		sRetour = "m"
      	CAS hRubRéel4, hRubRéel8
      		sRetour = "r"	
      	cas hRubImage, hRubMémoBinaire, hRubMémoBinaire4
      		sRetour = "bu"	
      	AUTRE CAS
      		
      FIN
      
      renvoyer sRetour
     type : 458752
   -
     name : GetInfoRubType
     procedure_id : 1443681465206658718
     type_code : 12
     code : |1-
      // Résumé : <indiquez ici ce que fait la procédure>
      // Syntaxe :
      //[ <Résultat> = ] GetInfoRubType (<nTypeHF_p> est entier [, <bComplet_p> est booléen])
      //
      // Paramètres :
      //	nTypeHF_p (entier) : <indiquez ici le rôle de nTypeHF_p>
      // 	bComplet_p (booléen - valeur par défaut=0) : <indiquez ici le rôle de bComplet_p>
      // Valeur de retour :
      // 	chaîne ANSI : <indiquez ici le rôle de la valeur de retour>
      //
      // Exemple :
      // <Indiquez ici un exemple d'utilisation>
      //
      procédure GetInfoRubType(nTypeHF_p est un entier, bComplet_p est un booléen = faux):chaine
      
      sRetour est une chaîne
      sDeclare est une chaîne
      
      SELON nTypeHF_p
      	CAS hRubBooléen : sRetour = "Booléen"
      	CAS hRubDate6 : sRetour = "Date sur 6"
      	CAS hRubDate8 : sRetour = "Date"
      	CAS hRubDateHeure : sRetour = "DateHeure"
      	CAS hRubEntier1 : sRetour = "Entier sur 1 octet"
      	CAS hRubEntier2 : sRetour = "Entier sur 2 octets"
      	CAS hRubEntier4 : sRetour = "Entier"
      	CAS hRubEntier8 : sRetour = "Entier sur 8 octets"
      	CAS hRubEntierNonSigné1 : sRetour = "Entier sans signe sur 1 octet"
      	CAS hRubEntierNonSigné2 : sRetour = "Entier sans signe sur 2 octets"
      	CAS hRubEntierNonSigné4 : sRetour = "Entier sans signe"
      	CAS hRubEntierNonSigné8 : sRetour = "Entier sans signe sur 8 octets"
      	CAS hRubMémoTexte : sRetour = "chaîne"
      	CAS hRubMémoUnicode : sRetour = "chaîne UNICODE"
      	CAS hRubMonétaire : sRetour = "Monétaire"
      	CAS hRubRéel4 : sRetour = "Réel"
      	CAS hRubRéel8 : sRetour = "Réel sur 8 octets"
      	CAS hRubTexte : sRetour = "chaîne"
      	CAS hRubTexteUnicode : sRetour = "chaîne UNICODE"
      	cas hRubImage, hRubMémoBinaire, hRubMémoBinaire4 : sRetour = "Buffer"
      	autre cas
      		ExceptionDéclenche(1,"")
      FIN
      
      
      si bComplet_p ALORS
      	si nTypeHF_p dans (hRubDate6, hRubDate8, hRubDateHeure) ALORS
      		sDeclare = "est une "
      	sinon
      		sDeclare = "est un "
      	FIN
      	sRetour = sDeclare + sRetour
      FIN
      
      renvoyer sRetour
     type : 458752
   -
     name : Analyse
     procedure_id : 1443681465206920862
     type_code : 12
     code : |1+
      // Résumé : <indiquez ici ce que fait la procédure>
      // Syntaxe :
      // Analyse ()
      //
      // Paramètres :
      //	Aucun
      // Valeur de retour :
      // 	Aucune
      //
      // Exemple :
      // <Indiquez ici un exemple d'utilisation>
      //
      procédure Analyse()
      
      
      sRubs		est une chaîne	= HListeRubrique(:m_sNomTable,hLstDétail)
      sLiaisons	est une chaîne	= HListeLiaison(:m_sNomTable)
      sLigne		est une chaîne
      sLigneCle	est une chaîne
      sRub		est une chaîne
      stRubTmp	est un STR_DefRub
      stCol		est un STR_InfoCol
      oGenTmp		est un ClZF_GenCodeFic dynamique
      sRubIdAuto	est une chaîne
      stRelTmp	est un str_rel
      
      
      
      sDeclareObj est une chaîne
      //On vérifie si la classe existe
      sDeclareObj = "oTmp est un " + :sNomClasseGen()
      si compile(sDeclareObj) = "" ALORS
      	:m_bClasseExiste = vrai
      	
      	//On vérifie su la classe est en LS
      	SI Compile(sDeclareObj + rc + "oTmp.ZF_bModeAjout()") = "" ALORS
      		:m_bClasseLS = Faux
      	SINON
      		:m_bClasseLS = vrai
      	FIN
      sinon
      	:m_bClasseExiste = faux
      FIN
      
      
      nIndRech est un entier
      
      pour nIndRech = 1 a 2
      	si sRubIdAuto = "" alors
      		//Identification de la PK de la table
      		POUR TOUTE CHAÎNE sLigne DE sRubs SÉPARÉE PAR RC
      			VariableRAZ(stRubTmp)
      			sRub = ExtraitChaîne(sLigne, 1)
      			
      			stRubTmp.nTypeRubHF = ExtraitChaîne(sLigne, 3)
      			
      			selon nIndRech
      				CAS 1
      					//Est on sur la clé primaire ?
      					SI stRubTmp.nTypeRubHF DANS (hRubIDAuto, hRubIDAuto4) ALORS
      						//Oui
      						sRubIdAuto = sRub
      					FIN
      					
      				CAS 2
      					//Est on sur la clé primaire ?
      					SI stRubTmp.nTypeRubHF DANS (hRubEntier1, hRubEntier2, hRubEntier4, hRubEntier8, hRubEntierNonSigné1, hRubEntierNonSigné2, hRubEntierNonSigné4, hRubEntierNonSigné8) et ...
      							{:m_sNomTable + "." + sRub,indRubrique}..TypeClé = hCléUnique ALORS
      						//Oui
      						sRubIdAuto = sRub
      					FIN
      					
      				AUTRE CAS
      					
      			FIN
      		fin
      	fin
      fin
      
      
      
      
      POUR TOUTE CHAÎNE sLigneCle DE sLiaisons SÉPARÉE PAR RC
      	
      	//Identification des relations associées à la clé primaire de la table en cours.
      	si ExtraitChaîne(sLigneCle,2,tab) = :m_sNomTable et ExtraitChaîne(sLigneCle,3,TAB) = sRubIdAuto ALORS
      		stRelTmp.sNomRel		= ExtraitChaîne(sLigneCle,1,TAB)
      		stRelTmp.sTablePK		= :m_sNomTable
      		stRelTmp.sRubriquePK	= sRubIdAuto
      		stRelTmp.sTableFK		= ExtraitChaîne(sLigneCle,5,TAB)
      		stRelTmp.sRubriqueFK	= ExtraitChaîne(sLigneCle,6,TAB)
      		stRelTmp.nTypeRel		=  nTypeRelDeNom(stRelTmp.sNomRel)
      		TableauAjoute(m_aFK_de_PK,stRelTmp)
      	FIN
      
      	SI ExtraitChaîne(sLigneCle,5,TAB) = :m_sNomTable ET ExtraitChaîne(sLigneCle,6,TAB) = sRubIdAuto ALORS
      		stRelTmp.sNomRel		= ExtraitChaîne(sLigneCle,1,TAB)
      		stRelTmp.sTablePK		= :m_sNomTable
      		stRelTmp.sRubriquePK	= sRubIdAuto
      		stRelTmp.sTableFK		= ExtraitChaîne(sLigneCle,2,TAB)
      		stRelTmp.sRubriqueFK	= ExtraitChaîne(sLigneCle,3,TAB)
      		stRelTmp.nTypeRel		=  nTypeRelDeNom(stRelTmp.sNomRel)
      		TableauAjoute(m_aFK_de_PK,stRelTmp)
      	FIN
      
      
      	//Identification des clés étrangères présentes dans la table en cours.
      	sRub = ExtraitChaîne(sLigneCle,3,TAB)
      	SI ExtraitChaîne(sLigneCle,2,TAB) = :m_sNomTable ET sRub <> sRubIdAuto ALORS
      		stRelTmp.sNomRel		= ExtraitChaîne(sLigneCle,1,TAB)
      		stRelTmp.sTablePK		= ExtraitChaîne(sLigneCle,5,TAB)
      		stRelTmp.sRubriquePK	= ExtraitChaîne(sLigneCle,6,TAB)
      		stRelTmp.sTableFK		= :m_sNomTable
      		stRelTmp.sRubriqueFK	= sRub
      		stRelTmp.nTypeRel		=  nTypeRelDeNom(stRelTmp.sNomRel)
      		m_aPK_de_FK[sRub]		= stRelTmp
      	FIN
      	
      	sRub = ExtraitChaîne(sLigneCle,6,TAB)
      	SI ExtraitChaîne(sLigneCle,5,TAB) = :m_sNomTable ET sRub <> sRubIdAuto ALORS
      		stRelTmp.sNomRel		= ExtraitChaîne(sLigneCle,1,TAB)
      		stRelTmp.sTablePK		= ExtraitChaîne(sLigneCle,2,TAB)
      		stRelTmp.sRubriquePK	= ExtraitChaîne(sLigneCle,3,TAB)
      		stRelTmp.sTableFK		= :m_sNomTable
      		stRelTmp.sRubriqueFK	= sRub
      		stRelTmp.nTypeRel		=  nTypeRelDeNom(stRelTmp.sNomRel)
      		m_aPK_de_FK[sRub]		= stRelTmp
      	FIN
      FIN
      
      
      
      POUR TOUTE CHAÎNE sLigne DE sRubs SÉPARÉE PAR RC
      	VariableRAZ(stRubTmp)
      	sRub = ExtraitChaîne(sLigne, 1)
      	
      	stRubTmp.nTypeRubHF = ExtraitChaîne(sLigne, 3)
      	
      	//Est on sur la clé primaire ?
      	SI sRub = sRubIdAuto ALORS
      		
      		//Mémorisation du nom de la clé
      		:m_sNomRubId = sRub
      		
      		//On liste les relations, pour identifier les clés étrangères, des autres tables
      		pour tout stRelTmp de m_aFK_de_PK
      			VariableRAZ(stCol)
      			stCol.sTableDesti	= stRelTmp.sTableFK
      			stCol.sCleDesti		= stRelTmp.sRubriqueFK
      			oGenTmp				= allouer un ClZF_GenCodeFic(stCol.sTableDesti)
      			stCol.sDeclaration	= "[%oGenTmp.sNomClasseColGen(vrai)%]_[%stRelTmp.sRubriqueFK%] est un [%oGenTmp.sNomClasseColGen()%]"
      			TableauAjoute(:m_aCol_Enfant, stCol)
      		FIN
      		
      	SINON
      		SELON ExtraitChaîne(sLigne, 2)
      			CAS "T"
      				stRubTmp.nTypeRub = ::cstDefRubChaine
      			CAS "N"
      				stRubTmp.nTypeRub = ::cstDefRubNum
      			AUTRE CAS
      				
      		FIN
      		
      		stRubTmp.bNullable			= {:m_sNomTable + "." + sRub,indRubrique}..NullAutorisé
      		stRubTmp.sLibelleRubrique	= {:m_sNomTable + "." + sRub,indRubrique}..libelle
      		stRubTmp.bVisibleUsr		= {:m_sNomTable + "." + sRub,indRubrique}..VisibleUtilisateurFinal
      		stRubTmp.nTaille			= {:m_sNomTable + "." + sRub,indRubrique}..Taille
      		stRubTmp.sValDef			= {:m_sNomTable + "." + sRub,indRubrique}..ValeurParDéfaut
      		stRubTmp.bVisibleInterface	= {:m_sNomTable + "." + sRub,indRubrique}..VisibleUtilisateurFinal
      		//stRubTmp.sMeta				= {:m_sNomTable + "." + sRub,indRubrique}..Métadonnées
      		
      		
      		selon {:m_sNomTable + "." + sRub,indRubrique}..TypeClé
      			CAS hNonClé
      				stRubTmp.nTypeCle = cstTypeCleAucune
      			CAS hCléUnique
      				stRubTmp.nTypeCle = cstTypeCleUnique
      			CAS hCléDoublon
      				stRubTmp.nTypeCle = cstTypeCleDoublon
      			AUTRE CAS
      				ExceptionDéclenche(1, "Cas non traité")
      		FIN
      		
      		
      		
      		//Parcourt de toutes les liaisons, de la table en cours
      		si pas m_aPK_de_FK[sRub]..vide alors
      			stRelTmp = m_aPK_de_FK[sRub]
      						
      			VariableRAZ(stCol)
      			stCol.sTableDesti		= stRelTmp.sTablePK
      			stCol.sCleDesti			= stRelTmp.sRubriquePK
      			oGenTmp					= allouer un ClZF_GenCodeFic(stCol.sTableDesti)
      			stCol.sDeclaration		= "[%oGenTmp.sNomClasseColGen(Vrai)%]_[%sRub%] est un [%oGenTmp.sNomClasseColGen()%]"
      			
      			stRubTmp.oObj_Parent	= oGenTmp
      			stRubTmp.nTypeRub		= ::cstDefRubObj
      		FIN
      		
      
      		SELON stRubTmp.nTypeRub
      			CAS ::cstDefRubObj
      				stRubTmp.sPrefixe				= "o"
      				stRubTmp.sNomDeclarationComplet	= "est un [%stRubTmp.oObj_Parent.sNomClasseGen()%] dynamique"
      				stRubTmp.sNomDeclarationCourt	= stRubTmp.oObj_Parent.sNomClasseGen()
      			AUTRE CAS
      				stRubTmp.sPrefixe				= :GetInfoRubPrefix(stRubTmp.nTypeRubHF)
      				stRubTmp.sNomDeclarationComplet	= :GetInfoRubType(stRubTmp.nTypeRubHF, Vrai)
      				stRubTmp.sNomDeclarationCourt	= :GetInfoRubType(stRubTmp.nTypeRubHF)
      			
      		FIN
      		
      		stRubTmp.sNomMembre = "m_[%stRubTmp.sPrefixe%][%sRub%]"
      		stRubTmp.sNomPropriete = "p_[%stRubTmp.sPrefixe%][%sRub%]"
      		
      		:m_aRub[sRub] = stRubTmp
      	FIN
      	
      FIN
     type : 458752
   -
     name : sNomClasseColGen
     procedure_id : 1443688143883210887
     type_code : 12
     code : |1+
      // Résumé : <indiquez ici ce que fait la procédure>
      // Syntaxe :
      //[ <Résultat> = ] sNomClasseColGen ( [<bObj_P> est booléen])
      //
      // Paramètres :
      //	bObj_P (booléen - valeur par défaut=0) : <indiquez ici le rôle de bObj_P>
      
      // Valeur de retour :
      // 	chaîne ANSI : <indiquez ici le rôle de la valeur de retour>
      //
      // Exemple :
      // <Indiquez ici un exemple d'utilisation>
      //
      procédure sNomClasseColGen(bObj_P est un booléen = faux):chaine
      
      si bObj_P ALORS
      	RENVOYER "oCol" + :m_sNomUsage
      sinon
      	RENVOYER "ClCol" + :m_sNomUsage
      FIN
      
     type : 458752
   -
     name : sNomClasseGen
     procedure_id : 1443688143883277127
     type_code : 12
     code : |1+
      // Résumé : <indiquez ici ce que fait la procédure>
      // Syntaxe :
      //[ <Résultat> = ] sNomClasseGen ()
      //
      // Paramètres :
      //	Aucun
      // Valeur de retour :
      // 	chaîne ANSI : <indiquez ici le rôle de la valeur de retour>
      //
      // Exemple :
      // <Indiquez ici un exemple d'utilisation>
      //
      procédure sNomClasseGen():chaine
      
      renvoyer "ClDb" + :m_sNomUsage
     type : 458752
   -
     name : nTypeRelDeNom
     procedure_id : 1464839140887792433
     type_code : 12
     code : |1+
      // Résumé : <indiquez ici ce que fait la procédure>
      // Syntaxe :
      //[ <Résultat> = ] nTypeRelDeNom (<sNomRel_p> est chaîne)
      //
      // Paramètres :
      //	sNomRel_p (chaîne ANSI) : <indiquez ici le rôle de sNomRel_p>
      
      // Valeur de retour :
      // 	entier : <indiquez ici le rôle de la valeur de retour>
      //
      // Exemple :
      // <Indiquez ici un exemple d'utilisation>
      //
      procédure privée nTypeRelDeNom(sNomRel_p est une chaîne) <métier>:entier
      
      sSufixe est une chaîne = ExtraitChaîne(sNomRel_p,1,"_",DepuisFin)
      selon majuscule(sSufixe)
      	CAS Majuscule(cstRelAsso_Suf)
      		renvoyer cstRelAsso
      	CAS Majuscule(cstRelAgr_Suf)
      		renvoyer cstRelAgr
      	CAS Majuscule(cstRelCompo_Suf)
      		renvoyer cstRelCompo
      	AUTRE CAS
      		renvoyer cstRelNonDef
      FIN
      
     type : 458752
   -
     name : sListeFicAna
     procedure_id : 1464991259952214531
     type_code : 12
     code : |1+
      procedure globale sListeFicAna()<metier>:chaine
      renvoyer HListeFichier()
     type : 458752
   -
     name : mEval
     procedure_id : 1469527698899029832
     type_code : 12
     code : |1+
      procedure mEval()<metier>:monetaire
      
      nCleTable		est un entier	= 1
      nCleRub			est un entier	= 2
      nCleRubFKAsso	est un entier	= 3
      nCleRubFKAgr	est un entier	= 4
      nCleRubFKCompo	est un entier	= 5
      nCleFen			est un entier	= 6
      nCleFenMetOrga	est un entier	= 7
      
      
      taVals est un tableau associatif de monétaires
      
      taVals[nCleTable]		= 25
      taVals[nCleRub]			= 3
      taVals[nCleRubFKAsso]	= 10
      taVals[nCleRubFKAgr]	= 5
      taVals[nCleRubFKCompo]	= 15
      taVals[nCleFen]			= 50
      taVals[nCleFenMetOrga]			= 100
      
      
      moRetour	est un monetaire
      sRub		est une chaîne
      stRub		est une STR_DefRub
      stRel		est une STR_Rel
      
      
      si :m_bClasseExiste alors
      	AddPx(nCleTable)
      	
      	pour tout stRub, sRub de :m_aRub
      		AddPx(nCleRub)
      		
      		si pas :m_bClasseLS ALORS
      			AddPx(nCleFen)
      		FIN
      		
      		//Eval mnt des méta types
      		selon :m_stConfigTbl.taRubs[sRub].sMeta
      			CAS ClZF_GenFenMeta.cstMetaoOrgani:
      				AddPx(nCleFenMetOrga)
      				
      			cas ClZF_GenFenMeta.cstMetaoOrgani_parent:
      				//Ras
      			AUTRE CAS
      				
      		FIN
      		
      		
      		si pas :M_aPK_de_FK[sRub]..vide ALORS
      			stRel = :m_aPK_de_FK[sRub]
      			selon stRel.nTypeRel
      				CAS cstRelAsso
      					AddPx(nCleRubFKAsso)
      				CAS cstRelAgr
      					AddPx(nCleRubFKAgr)
      				CAS cstRelCompo
      					AddPx(nCleRubFKCompo)
      				AUTRE CAS
      					
      			FIN
      		FIN
      		
      	FIN
      fin	
      
      renvoyer moRetour
      
      procédure interne AddPx(nCle_p est un entier):vide
      	moRetour += taVals[nCle_p]
      fin
      
      
      
     type : 458752
   -
     name : sNomFicConf
     procedure_id : 1472168425190691182
     type_code : 12
     code : |1-
      procedure prive sNomFicConf()<metier>:chaine
      renvoyer :m_sNomTable + ".json"
     type : 458752
   -
     name : chargeConfTable
     procedure_id : 1472108682186412195
     type_code : 12
     code : |1+
      PROCÉDURE chargeConfTable()<métier>:Vide
      
      sFicJSON		est une chaîne	= sNomFicConf()
      sJson			est une chaîne
      stRubAnaTmp		est un str_DefRub
      
      
      SI fFichierExiste(sFicJSON) ALORS
      	sJson			= fChargeTexte(sFicJSON)
      	Désérialise(m_stConfigTbl, sJson, psdJSON)
      FIN
      
      //S'il y a plus de rubriques que ce qui est récupéré, on complète
      POUR TOUT ÉLÉMENT stRubAnaTmp, sRub DE :m_aRub
      	si m_stConfigTbl.taRubs[sRub]..Vide ALORS
      		m_stConfigTbl.taRubs[sRub] = allouer un STR_DescRub
      	FIN
      FIN
     type : 458752
   -
     name : sauveConfTable
     procedure_id : 1472164834592412051
     type_code : 12
     code : |1+
      PROCÉDURE sauveConfTable(stSauve est un STR_DescFic)<métier>:Vide
      
      sJson		est une chaîne
      Sérialise(stSauve, sJson, psdJSON)
      fSauveTexte(sNomFicConf(),sJson)
     type : 458752
   -
     name : aTableDependances
     procedure_id : 1474825930687461673
     type_code : 12
     code : |1-
      // Résumé : <indiquez ici ce que fait la procédure>
      // Syntaxe :
      //[ <Résultat> = ] aTableDependances ()
      //
      // Paramètres :
      //	Aucun
      
      // Valeur de retour :
      // 	tableau (chaîne ANSI) : <indiquez ici le rôle de la valeur de retour>
      //
      // Exemple :
      // <Indiquez ici un exemple d'utilisation>
      //
      procédure publique globale aTableDependances()<metier>:tableau de chaines
      
      taTbls	est un tableau associatif de ClZF_GenCodeFic dynamique
      pclStTblTmp	est un ClZF_GenCodeFic dynamique
      aRetour	est un tableau de chaînes
      sTbl	est une chaîne
      bMqt	est un booléen
      stRel	est un ClZF_GenCodeFic.STR_Rel
      
      
      pour toute chaine sTbl de sListeFicAna() separee par rc
      	taTbls[sTbl] = allouer un ClZF_GenCodeFic(sTbl)
      	taTbls[sTbl].Analyse()
      FIN
      
      
      tantque taTbls..Occurrence > 0
      	
      	
      	pour tout pclStTblTmp, sTbl de taTbls
      		bMqt = faux
      		
      		pour tout stRel de pclStTblTmp.m_aPK_de_FK
      			si stRel.sTablePK <> sTbl _et_ TableauCherche(aRetour,tcLinéaire,stRel.sTablePK) <= 0 ALORS
      				bMqt = vrai
      			FIN
      		FIN
      		
      		
      		
      		si pas bMqt ALORS
      			TableauAjoute(aRetour, sTbl)
      			TableauSupprime(taTbls, sTbl)
      		FIN
      	FIN
      	
      	
      	
      FIN
      
      
      
      
      renvoyer aRetour
     type : 458752
  properties :
   -
     name : p_sNomTable
     identifier : 0x1408fca4c66a569e
     type_code : 103
     p_codes :
      -
        code : |1-
         procédure publique p_sNomTable() : chaîne
         
         renvoyer m_sNomTable
        type : 1966080
     template_refs : []
   -
     name : p_sNomRubId
     identifier : 0x14090446c9e22a7b
     type_code : 103
     p_codes :
      -
        code : |1-
         procédure publique p_sNomRubId() : chaîne
         
         renvoyer m_sNomRubId
        type : 1966080
     template_refs : []
   -
     name : p_sNomUsage
     identifier : 0x1409044fc9e34ca9
     type_code : 103
     p_codes :
      -
        code : |1-
         procédure publique p_sNomUsage() : chaîne
         
         renvoyer m_sNomUsage
        type : 1966080
     template_refs : []
   -
     name : p_bClasseExiste
     identifier : 0x145a0a470b0be1a3
     type_code : 103
     p_codes :
      -
        code : |1-
         procédure publique p_bClasseExiste() : booléen
         
         renvoyer m_bClasseExiste
        type : 1966080
     template_refs : []
   -
     name : p_sLibelle
     identifier : 0x14624010024fb040
     type_code : 103
     p_codes :
      -
        code : |1-
         procédure publique p_sLibelle() : chaîne
         
         renvoyer m_sLibelle
        type : 1966080
     template_refs : []
   -
     name : p_bClasseLS
     identifier : 0x1464dc3301b14df2
     type_code : 103
     p_codes :
      -
        code : |1-
         procédure publique p_bClasseLS() : booléen
         
         renvoyer m_bClasseLS
        type : 1966080
     template_refs : []
  procedure_templates : []
  property_templates : []
 code_parameters :
  internal_properties : BwAAAAcAAAA6ih3UbgNXHwTtiPSFUEj+2fi/m7v4QV2rqidAupM=
  original_name : Classe1
resources :
 string_res :
  identifier : 0x13e8dca31b897f1f
  internal_properties : BwAAAAcAAAAnMYFQ1bL/vz9ehh7L22SNNSlIzGTOI8h5F/WtgDNP
custom_note :
 internal_properties : BwAAAAcAAABtB9HWVzrXO2+4NDRVK0vmzaNKrCKqH1DBX30lMmGZ
